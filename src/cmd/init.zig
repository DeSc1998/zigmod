const std = @import("std");
const gpa = std.heap.c_allocator;

const inquirer = @import("inquirer");
const detectlicense = @import("detect-license");
const u = @import("./../util/index.zig");

//
//

pub fn execute(args: [][]u8) !void {
    _ = args;

    std.debug.print("This utility will walk you through creating a zig.mod file.\n", .{});
    std.debug.print("That will give a good launching off point to get your next project started.\n", .{});
    std.debug.print("Use `zigmod aq add <pkg>` to add a dependency from https://aquila.red/\n", .{});
    std.debug.print("Press ^C at any time to quit.\n", .{});
    std.debug.print("\n", .{});

    const stdout = std.io.getStdOut().writer();
    const stdin = std.io.getStdIn().reader();

    const id = try inquirer.answer(stdout, "ID (this gets autogenerated):", []const u8, "{s}", try u.random_string(48));

    const ptype = try inquirer.forEnum(stdout, stdin, "Are you making an application or a library?", gpa, enum { exe, lib }, null);

    const name = try inquirer.forString(stdout, stdin, "package name:", gpa, u.detect_pkgname(u.try_index([]const u8, args, 0, ""), "") catch |err| switch (err) {
        error.NoBuildZig => {
            u.assert(false, "init requires a build.zig file", .{});
            unreachable;
        },
        else => return err,
    });

    const entry = if (ptype == .lib) try inquirer.forString(stdout, stdin, "package entry point:", gpa, u.detct_mainfile(u.try_index([]const u8, args, 1, ""), null, name) catch |err| switch (err) {
        error.CantFindMain => null,
        else => return err,
    }) else null;

    const license = try inquirer.forString(stdout, stdin, "license:", gpa, try detectlicense.detectInDir(gpa, std.fs.cwd()));

    const description = try inquirer.forString(stdout, stdin, "description:", gpa, null);

    std.debug.print("\n", .{});
    std.debug.print("About to write local zig.mod:\n", .{});

    std.debug.print("\n", .{});
    switch (ptype) {
        .exe => try writeExeManifest(stdout, id, name, license, description),
        .lib => try writeLibManifest(stdout, id, name, entry.?, license, description),
    }

    std.debug.print("\n", .{});
    switch (try inquirer.forConfirm(stdout, stdin, "Is this okay?", gpa)) {
        false => {
            std.debug.print("okay. quitting...", .{});
        },
        true => {
            const file = try std.fs.cwd().createFile("zig.mod", .{});
            defer file.close();
            const w = file.writer();
            switch (ptype) {
                .exe => try writeExeManifest(w, id, name, license, description),
                .lib => try writeLibManifest(w, id, name, entry.?, license, description),
            }
            std.debug.print("\n", .{});
            u.print("Successfully initialized new package {s}!\n", .{name});
        },
    }
}

fn writeExeManifest(w: std.fs.File.Writer, id: []const u8, name: []const u8, license: []const u8, description: []const u8) !void {
    try w.print("id: {s}\n", .{id});
    try w.print("name: {s}\n", .{name});
    try w.print("license: {s}\n", .{license});
    try w.print("description: {s}\n", .{description});
    try w.print("dev_dependencies:\n", .{});
}

fn writeLibManifest(w: std.fs.File.Writer, id: []const u8, name: []const u8, entry: []const u8, license: []const u8, description: []const u8) !void {
    try w.print("id: {s}\n", .{id});
    try w.print("name: {s}\n", .{name});
    try w.print("main: {s}\n", .{entry});
    try w.print("license: {s}\n", .{license});
    try w.print("description: {s}\n", .{description});
    try w.print("dependencies:\n", .{});
}
