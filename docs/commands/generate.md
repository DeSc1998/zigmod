## `generate` command
```
zigmod generate
```

- This command takes no parameters and will generate a `deps.zig` in the root of your project. This is the file that you will then import into your `build.zig` to automatically add all the necessary packages and (any) C code that may be in your dependencies.
- This behavior is similar to [`zigmod fetch`](./fetch.md) but it does the fetching of dependencies in `deps.zig` itself to enable your users to only need `zig build` (and optionally `git`).
- You as an program author will still need `zigmod` installed during development, but consumers of your app can get started with only a `git clone` and `zig build`!
- To this end, a `deps.zig` made by running `zigmod generate` *will* want to be checked into source control. Don't forget to remove it from `.gitignore`.
- The version of dependencies fetched by `deps.zig` from this command is based on your `zigmod.lock` so no surprise breaks from users.

For a full reference on the fields available in `deps.zig` you can check [here](../deps.zig.md).

### Adding `deps.zig` to your `build.zig`
```diff
 const std = @import("std");
+const deps = @import("./deps.zig");
 
 pub fn build(b: *std.build.Builder) void {
     const target = b.standardTargetOptions(.{});
 
     const mode = b.standardReleaseOptions();
 
     const exe = b.addExecutable("hello", "src/main.zig");
     exe.setTarget(target);
     exe.setBuildMode(mode);
+    deps.addAllTo(exe);
     exe.install();
```

If you don't want Zigmod to handle adding packages to your project and only do resource fetching then `deps.fetch(exe)` may be called independently of `deps.addAllTo(exe)`.

`deps.addAllTo(exe)` will call `deps.fetch(exe)` inside of it, so as to be compatible with `deps.zig` generated by `zigmod fetch`.
